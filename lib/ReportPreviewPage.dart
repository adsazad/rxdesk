import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';

class ReportPreviewPage extends StatefulWidget {
  final Map<String, dynamic> patient;
  final List<Map<String, dynamic>> breathStats;
  final List<String>?
  graphBase64List; // Optional: List of base64 PNGs for graphs

  const ReportPreviewPage({
    Key? key,
    required this.patient,
    required this.breathStats,
    this.graphBase64List,
  }) : super(key: key);

  @override
  State<ReportPreviewPage> createState() => _ReportPreviewPageState();
}

class _ReportPreviewPageState extends State<ReportPreviewPage> {
  late String htmlContent;

  @override
  void initState() {
    super.initState();
    // pdf
  }

  List<String> getBreathStatsHeaders(List<Map<String, dynamic>> breathStats) {
    if (breathStats.isEmpty) return [];
    return breathStats.first.keys.toList();
  }

  List<List<String>> getBreathStatsRows(
    List<Map<String, dynamic>> breathStats,
    List<String> headers,
  ) {
    return breathStats.map((row) {
      return headers.map((h) {
        final val = row[h];
        if (val == null) return '-';
        if (val is double) return val.toStringAsFixed(3);
        return val.toString();
      }).toList();
    }).toList();
  }

  Future<Uint8List> _buildPdf(PdfPageFormat format) async {
    print('Building PDF with format: $format');

    print(widget.breathStats);
    final pdf = pw.Document();

    final patientName = widget.patient['name'] ?? '';
    final patientAge = widget.patient['age']?.toString() ?? '';
    final patientGender = widget.patient['gender'] ?? '';
    final patientWeight = widget.patient['weight']?.toString() ?? '';
    final reportDate = DateTime.now().toString().split(' ').first;

    // Dynamically get headers and rows
    final headers = getBreathStatsHeaders(widget.breathStats);
    final rows = getBreathStatsRows(widget.breathStats, headers);

    print('Headers: $headers');
    print('Rows: $rows');

    pdf.addPage(
      pw.MultiPage(
        pageFormat: format,
        build:
            (context) => [
              pw.Center(
                child: pw.Text(
                  'Breath Stats Report',
                  style: pw.TextStyle(
                    fontSize: 28,
                    fontWeight: pw.FontWeight.bold,
                  ),
                ),
              ),
              pw.SizedBox(height: 16),
              pw.Text('Patient Name: $patientName'),
              pw.Text('Age: $patientAge'),
              pw.Text('Gender: $patientGender'),
              pw.Text('Weight: $patientWeight kg'),
              pw.Text('Date: $reportDate'),
              pw.Divider(),
              if (widget.graphBase64List != null &&
                  widget.graphBase64List!.isNotEmpty)
                ...widget.graphBase64List!.map(
                  (base64String) => pw.Padding(
                    padding: const pw.EdgeInsets.symmetric(vertical: 8),
                    child: pw.Image(
                      pw.MemoryImage(
                        base64Decode(base64String.split(',').last),
                      ),
                    ),
                  ),
                ),
              pw.Text(
                'Breath Stats:',
                style: pw.TextStyle(fontWeight: pw.FontWeight.bold),
              ),
              pw.SizedBox(height: 8),
              pw.TableHelper.fromTextArray(
                headers: headers,
                data: rows,
                cellAlignment: pw.Alignment.center,
                headerStyle: pw.TextStyle(fontWeight: pw.FontWeight.bold),
                headerDecoration: pw.BoxDecoration(color: PdfColors.grey300),
                cellStyle: pw.TextStyle(fontSize: 8),
                cellHeight: 18,
                columnWidths: {
                  for (var i = 0; i < headers.length; i++)
                    i: const pw.FlexColumnWidth(),
                },
              ),
              pw.SizedBox(height: 20),
              pw.Align(
                alignment: pw.Alignment.centerRight,
                child: pw.Text(
                  'Generated by SpiroBT | $reportDate',
                  style: pw.TextStyle(fontSize: 10),
                ),
              ),
            ],
      ),
    );

    return pdf.save();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Report Preview'),
        actions: [
          IconButton(
            icon: const Icon(Icons.picture_as_pdf),
            tooltip: 'Export as PDF',
            onPressed: () async {
              await Printing.layoutPdf(onLayout: _buildPdf);
            },
          ),
        ],
      ),
      body: PdfPreview(
        build: _buildPdf,
        canChangePageFormat: false,
        canChangeOrientation: false,
        canDebug: false,
        allowPrinting: false,
        allowSharing: false,
      ),
    );
  }
}

Future<File> generateBreathStatsPdf({
  required String filePath,
  required Map<String, dynamic> patient,
  required List<Map<String, dynamic>> breathStats,
  List<File>? chartImages, // Optional: chart images as File
}) async {
  final pdf = pw.Document();

  // Prepare patient info
  final patientName = patient['name'] ?? '';
  final patientAge = patient['age']?.toString() ?? '';
  final patientGender = patient['gender'] ?? '';
  final patientWeight = patient['weight']?.toString() ?? '';
  final reportDate = DateTime.now().toString().split(' ').first;

  // Prepare table headers and rows
  final headers = [
    "V'O₂ [L/min]",
    "V'O₂/kg [mL/min/kg]",
    "V'CO₂ [L/min]",
    "RER []",
    "V'E [L/min]",
    "VT [L]",
    "HR [1/min]",
  ];
  final rows =
      breathStats
          .map(
            (row) => [
              row['vo2']?.toString() ?? '',
              row['vo2kg']?.toString() ?? '',
              row['vco2']?.toString() ?? '',
              row['rer']?.toString() ?? '',
              row['minuteVentilation']?.toString() ?? '',
              row['vt']?.toString() ?? '',
              row['hr']?.toString() ?? '',
            ],
          )
          .toList();

  pdf.addPage(
    pw.Page(
      build:
          (context) => pw.Column(
            crossAxisAlignment: pw.CrossAxisAlignment.start,
            children: [
              pw.Center(
                child: pw.Text(
                  'Breath Stats Report',
                  style: pw.TextStyle(
                    fontSize: 28,
                    fontWeight: pw.FontWeight.bold,
                  ),
                ),
              ),
              pw.SizedBox(height: 16),
              pw.Text('Patient Name: $patientName'),
              pw.Text('Age: $patientAge'),
              pw.Text('Gender: $patientGender'),
              pw.Text('Weight: $patientWeight kg'),
              pw.Text('Date: $reportDate'),
              pw.Divider(),
              if (chartImages != null && chartImages.isNotEmpty)
                ...chartImages.map(
                  (imgFile) => pw.Padding(
                    padding: const pw.EdgeInsets.symmetric(vertical: 8),
                    child: pw.Image(pw.MemoryImage(imgFile.readAsBytesSync())),
                  ),
                ),
              pw.Text(
                'Breath Stats:',
                style: pw.TextStyle(fontWeight: pw.FontWeight.bold),
              ),
              pw.Table.fromTextArray(
                headers: headers,
                data: rows,
                cellAlignment: pw.Alignment.center,
                headerStyle: pw.TextStyle(fontWeight: pw.FontWeight.bold),
                headerDecoration: pw.BoxDecoration(color: PdfColors.grey300),
              ),
              pw.SizedBox(height: 20),
              pw.Align(
                alignment: pw.Alignment.centerRight,
                child: pw.Text(
                  'Generated by SpiroBT | $reportDate',
                  style: pw.TextStyle(fontSize: 10),
                ),
              ),
            ],
          ),
    ),
  );

  final file = File(filePath);
  await file.writeAsBytes(await pdf.save());
  return file;
}
